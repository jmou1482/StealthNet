/******************************************************************************
 * ELEC5616
 * Computer and Network Security, The University of Sydney
 * Copyright (C) 2002-2004, Matt Barrie, Stephen Gould and Ryan Junee
 *
 * PACKAGE:         StealthNet
 * FILENAME:        Packet.java
 * AUTHORS:         Matt Barrie, Stephen Gould and Ryan Junee
 * DESCRIPTION:     Implementation of StealthNet Communications for ELEC5616
 *                  programming assignment.
 *                  This code has been written for the purposes of teaching
 *                  cryptography and computer security. It is to be used as
 *                  a demonstration only. No attempt has been made to optimise
 *                  the source code.
 * VERSION:         1.0-ICE
 *
 *****************************************************************************/

package StealthNet;

/* Import Libraries **********************************************************/

import StealthNet.Security.MessageAuthenticationCode;
import StealthNet.Security.TokenGenerator;

/* StealthNet.Packet Class Definition ****************************************/

/**
 * A class to store the data passed between StealthNet clients. A StealthNet
 * "packet" consists of three parts:
 *     - command
 *     - data
 *     - token
 *     - digest
 *  
 * A message digest is produced by passing a MessageAuthenticationCode instance
 * to the relevant function. The StealthNet Packet class will allow packets to 
 * be created without a digest (if a null MessageAuthenticationCode instance is
 * passed to the function, for instance). A higher layer should check whether or
 * not this should be allowed. Note that the message digest is calculated last,
 * as its value depends on the command, the data and the token.
 *  
 * A message token is generated by a pseudo-random random generator. The message 
 * token is used to prevent replay attacks, because once the packet is read at 
 * the receiving end of the communications, the token is "consumed" and cannot 
 * be used again for future communications. The Packet class WILL allow packets 
 * to be created without a token (if a null TokenGenerator instance is passed to
 * the function). A higher layer should check whether or not this should be 
 * allowed.
 * 
 * @author Matt Barrie
 * @author Stephen Gould
 * @author Ryan Junee
 * @author Joshua Spence
 */
public class Packet {
	/** Commands. */
    public static final byte CMD_NULL = 0x00;
    public static final byte CMD_LOGIN = 0x01;
    public static final byte CMD_LOGOUT = 0x02;
    public static final byte CMD_MSG = 0x03;
    public static final byte CMD_CHAT = 0x04;
    public static final byte CMD_FTP = 0x05;
    public static final byte CMD_LIST = 0x06;
    public static final byte CMD_CREATESECRET = 0x07;
    public static final byte CMD_SECRETLIST = 0x08;
    public static final byte CMD_GETSECRET = 0x09;
    
    /** 
     * Security-specific commands - these should never be returned to a client 
     * or server, but rather should always be handled within the Comms class. 
     */
    public static final byte CMD_AUTHENTICATIONKEY = 0x0A;
    public static final byte CMD_INTEGRITYKEY = 0x0B;
    public static final byte CMD_TOKENSEED = 0x0C;
    
    /** A byte used to describe the Long token. */
    private static final byte TOKEN_NULL     = 0x00;
    private static final byte TOKEN_POSITIVE = 0x01;
    private static final byte TOKEN_NEGATIVE = 0x02;
    
    /** Hexadecimal characters. */
    private static final char[] HEXTABLE = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

    /** Packet contents. */
    byte command;			/** The command being sent in the packet. */      
    final byte data[];		/** The data being sent in the packet. */
    final Long token;		/** The pseudo-random token for this packet. */
    final byte[] digest;	/** The MAC digest of the packet data (in base64 encoding). */

    /** Null constructor with no digest and no token. */
    public Packet() {
        this.command = CMD_NULL;
        this.data = new byte[0];
        
        /** No digest is available. */
        this.digest = new byte[0];
        
        /** No token is available. */
        this.token = null;
    }

    /** 
     * Constructor with no digest. Explicitly copies the data array contents.
     *
     * @param cmd The command to be sent in the packet.
     * @param d The data to be sent in the packet.
     */
    public Packet(byte cmd, byte[] d) {
        this.command = cmd;
        
        if (d == null)
        	this.data = new byte[0];
        else {
        	this.data = new byte[d.length];
        	System.arraycopy(d, 0, this.data, 0, d.length);
        }
        
        /** No digest is available. */
        this.digest = new byte[0];
        
        /** No token is available. */
        this.token = null;
    }
    
    /** 
     * Constructor with digest and token. Explicitly copies the data array 
     * contents.
     *
     * @param cmd The command to be sent in the packet.
     * @param dLen The length of the data array.
     * @param d The data to be sent in the packet.
     * @param mac The MessageAuthenticationCode instance to provide a MAC 
     * digest.
     * @param tokenGenerator The TokenGenerator instance to provide a token
     * number.
     */
    public Packet(byte cmd, byte[] d, int dLen, MessageAuthenticationCode mac, TokenGenerator tokenGenerator) {
        this.command = cmd;
        
        /** Copy the data. */
        if (d == null)
        	this.data = new byte[0];
        else  {
        	this.data = new byte[dLen];
        	System.arraycopy(d, 0, this.data, 0, dLen);
        }
        
        /** Create the token (if possible). */
        if (tokenGenerator != null)
        	this.token = new Long(tokenGenerator.getNext());
        else
        	this.token = null;
        
        /** Create the MAC digest (if possible). */
        if (mac == null)
        	this.digest = new byte[0];
        else
        	this.digest = mac.createMAC(getContents()).getBytes();
    }

    /** 
     * Constructor. This function must "undo" the effects of the toString() 
     * function, because this function converts the received data into a packet
     * at the receiving end of communications.
     * 
     * @param str A string consisting of the packet contents.
     */
    public Packet(String str) {  
    	/** 
    	 * Add padding if necessary, to make the packet length an integer number
    	 * of bytes (each represented by 2 hexadecimal characters).
    	 */
    	if (str.length() % 2 == 1)
            str = "0" + str;
    	
        if (str.length() == 0) {
        	/** NULL packet. */
            this.command = CMD_NULL;
            this.data = new byte[0];
            this.digest = new byte[0];
            this.token = null;
        } else {
        	/** Current index of the string. */
        	int current = 0;
        	
        	/** Command (1 byte). */
            this.command = (byte) (16 * singleHexToInt(str.charAt(current++)) + singleHexToInt(str.charAt(current++)));
            
            /** Data length (2 bytes). */
            int dataLen = hexToInt(str.substring(current, current + 8));
            current += 8;
            
            /** Data (dataLen bytes). */
            this.data = new byte[dataLen];
            for (int i = 0; i < data.length; i++)
            	this.data[i] = (byte) (16 * singleHexToInt(str.charAt(current++)) + singleHexToInt(str.charAt(current++)));
            
            /** 
             * Token (8 bytes + 1 byte for sign).
             * 
             *  NOTE: I had issues here with encoding/decoding hexadecimal 
             *  strings to and from a negative long. My solution was to only
             *  encode positive longs in the packet output string, and to 
             *  indicate the sign of the long token using a single byte before
             *  the hexadecimal long.
             */
            final byte tokenProperties = (byte) (16 * singleHexToInt(str.charAt(current++)) + singleHexToInt(str.charAt(current++)));
    		switch (tokenProperties) {
	    		case TOKEN_NULL:
	    			this.token = null;
	    			break;
	    			
	    		case TOKEN_NEGATIVE:
	    			this.token = new Long(-1 * hexToLong(str.substring(current, current + 16)));
	    			break;
	    			
    			default:
    			case TOKEN_POSITIVE:
    				this.token = new Long(hexToLong(str.substring(current, current + 16)));
    		}
    		current += 16;
            
            /** Digest length (2 bytes). */
            int digestLen = hexToInt(str.substring(current, current + 8));
            current += 8;
            
            /** Digest (digestLen bytes). */
            this.digest = new byte[digestLen];
            for (int i = 0; i < digest.length; i++)
            	this.digest[i] = (byte) (16 * singleHexToInt(str.charAt(current++)) + singleHexToInt(str.charAt(current++)));
        }
    }
    
    /** 
     * Gets a string containing everything except for the MAC digest. Used to
     * compute the MAC digest. Also called by toString().
     * 
     * @return A string representing the contents of the packet.
     */
    private String getContents() {
        String str = "";
        int lowHalfByte, highHalfByte;

        /** Command (1 byte).  */
        highHalfByte = (command >= 0) ? command : (256 + command);
        lowHalfByte = highHalfByte & 0xF;
        highHalfByte /= 16;
        str += HEXTABLE[highHalfByte];
        str += HEXTABLE[lowHalfByte];
        
        /** Data length (2 bytes). */
        str += intToHex(data.length);
        
        /** Data (dataLen bytes). */
        for (int i = 0; i < data.length; i++) {
        	highHalfByte = (data[i] >= 0) ? data[i] : 256 + data[i];
        	lowHalfByte = highHalfByte & 0xF;
            highHalfByte /= 16;
            str += HEXTABLE[highHalfByte];
            str += HEXTABLE[lowHalfByte];
        }
        
        /** Token (1 byte for properties + 8 bytes for value). */
        byte tokProp;
        long tokVal;
        if (token == null) {
        	tokProp = TOKEN_NULL; 
        	tokVal = 0L;
        } else {
        	if (token.longValue() < 0) {
        		tokProp = TOKEN_NEGATIVE; 
        		tokVal = -token.longValue();
        	} else {
        		tokProp = TOKEN_POSITIVE; 
        		tokVal = token.longValue();
        	}
        }
        /* Token property. */
        highHalfByte = (tokProp >= 0) ? tokProp : (256 + tokProp);
        lowHalfByte = highHalfByte & 0xF;
        highHalfByte /= 16;
        str += HEXTABLE[highHalfByte];
        str += HEXTABLE[lowHalfByte];
        /* Token value. */
        str += longToHex(tokVal);
        
        /** Done. */
        return str;
    }

    /** 
     * Converts the packet to a string. This function must undo the effects of 
     * the StealthNet.Packet(String) constructor, because this function is used
     * to convert a packet to a string for transmission at the sending end of
     * communications.
     * 
     * @return A string representing the contents of the packet.
     */
    public String toString() {
        String str = getContents();
        int lowHalfByte, highHalfByte;
        
        /** MAC Digest length (2 bytes) */
        str += intToHex(digest.length);
        
        /** MAC Digest (digestLen bytes). */
        for (int i = 0; i < digest.length; i++) {
        	highHalfByte = (digest[i] >= 0) ? digest[i] : (256 + digest[i]);
        	lowHalfByte = highHalfByte & 0xF;
            highHalfByte /= 16;
            str += HEXTABLE[highHalfByte];
            str += HEXTABLE[lowHalfByte];
        }

        return str;
    }
    
    /**
     * Verify a MAC digest by calculating our own MAC digest of the same data,
     * and comparing it with the MAC digest stored in the packet. If the 
     * MessageAuthenticationCode instance is null, then the verification will 
     * pass automatically. Beware that this may not always be the desired 
     * result, so this should be checked at a higher layer.
     * 
     * @param mac The MessageAuthenticationCode instance to calculate the MAC 
     * digest.
     * @return True if the digest matches (or if the MessageAuthenticationCode 
     * instance is null), otherwise false.
     */
    public boolean verifyMAC(MessageAuthenticationCode mac) {
    	if (mac == null)
    		return true;
    	else
    		return mac.verifyMAC(getContents(), digest);
    }

    /** 
     * A utility function to convert a single hexadecimal character to a decimal
     * integer.
     * 
     * @param hex The hexadecimal character to convert to an integer.
     * @return The integer value of the hexadecimal character.
     */
    private static int singleHexToInt(char hex) {
             if ((hex >= '0') && (hex <= '9')) return (hex - '0');
        else if ((hex >= 'A') && (hex <= 'F')) return (hex - 'A' + 10);
        else if ((hex >= 'a') && (hex <= 'f')) return (hex - 'a' + 10);
        else return 0;
    }
    
    /**
     * Convert a hexadecimal string to a long.
     * 
     * @param hex The string to convert.
     * @return The long represented by the hexadecimal string.
     */
    private static long hexToLong(String hex) {
    	return Long.parseLong(hex, 16);
	}

    /**
     * Convert a long to a hexadecimal string. The length of the hexadecimal 
     * string will be equal to the length that would be required to encode
     * Long.MAX_VALUE as a hexadecimal string.
     * 
     * @param value The long to convert.
     * @return The hexadecimal string representing the long.
     */
	private static String longToHex(long value) {
		String result = Long.toHexString(value);
		
		/** Pad the result to use the full 8 bytes of a long. */
		while (result.length() < 16)
			result = "0" + result;
		
		return result;
	}
	
	/**
     * Convert a hexadecimal string to an integer.
     * 
     * @param hex The string to convert.
     * @return An integer representing the hexadecimal string.
     */
	private static int hexToInt(String hex) {
    	return Integer.parseInt(hex, 16);
	}
	
	/**
     * Convert an integer to a hexadecimal string. The length of the hexadecimal 
     * string will be equal to the length that would be required to encode
     * Integer.MAX_VALUE as a hexadecimal string.
     * 
     * @param value The integer to convert.
     * @return The hexadecimal string representing the integer.
     */
	private static String intToHex(int value) {
		String result = Integer.toHexString(value);
		
		/** Pad the result to use the full 4 bytes of an integer. */
		while (result.length() < 8)
			result = "0" + result;
		
		return result;
	}
    
    /**
     * Get the name of a command from its byte value. For debug purposes only.
     * 
     * @param command The byte value of the command to query the name of.
     * @return A String containing the name of the command.
     */
    public static String getCommandName(byte command) {
    	switch (command) {
    		case CMD_NULL:
				return "CMD_NULL";
    		case CMD_LOGIN:
    			return "CMD_LOGIN";
    		case CMD_LOGOUT:
    			return "CMD_LOGOUT";
    		case CMD_MSG:
				return "CMD_MSG";
    		case CMD_CHAT:
    			return "CMD_CHAT";
    		case CMD_FTP:
    			return "CMD_FTP";
    		case CMD_LIST:
    			return "CMD_LIST";
    		case CMD_CREATESECRET:
    			return "CMD_CREATESECRET";
    		case CMD_SECRETLIST:
				return "CMD_SECRETLIST";
    		case CMD_GETSECRET:
    			return "CMD_GETSECRET";
    		case CMD_AUTHENTICATIONKEY:
				return "CMD_AUTHENTICATIONKEY";
    		case CMD_INTEGRITYKEY:
				return "CMD_INTEGRITYKEY";
    		case CMD_TOKENSEED:
    			return "CMD_TOKENSEED";
			default:
				return "UNKNOWN";
    	}
    }
    
    /**
     * Get a string representation of the packet. For debug purposes only. 
     * 
     * @param command The byte value of the command to query the name of.
     * @return A comma-separated string containing the the value of each of the
     * packet's fields. For purely cosmetic purposes, newline characters will be
     * replaced by semicolons.
     */
    public String getDecodedString() {
    	String str = "";
    	
    	/** Packet name. */
    	str += getCommandName(command);
    	str += ", ";
    	
    	/** Packet data. */
    	if (data.length > 0)
    		str += (new String(data)).replaceAll("\n", ";");
    	else
    		str += "null";
    	str += ", ";
    	
    	/** Packet token. */
    	if (token != null)
    		str += token.toString();
    	else
    		str += "null";
    	str += ", ";
    	
    	/** Packet digest. */
    	if (digest.length > 0)
    		str += (new String(digest));
    	else
    		str += "null";
    	
    	return str;
    }
}

/******************************************************************************
 * END OF FILE:     Packet.java
 *****************************************************************************/