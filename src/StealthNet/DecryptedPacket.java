/******************************************************************************
 * ELEC5616
 * Computer and Network Security, The University of Sydney
 * Copyright (C) 2002-2004, Matt Barrie, Stephen Gould and Ryan Junee
 *
 * PACKAGE:         StealthNet
 * FILENAME:        DecryptedPacket.java
 * AUTHORS:         Matt Barrie, Stephen Gould, Ryan Junee and Joshua Spence
 * DESCRIPTION:     Implementation of a StealthNet packet. This class represents
 * 					decrypted packet contents. This class is more closely based
 * 					on the original 'Packet' class than the EncryptedPacket
 * 					class.
 *
 *****************************************************************************/

package StealthNet;

/* Import Libraries **********************************************************/

import java.io.UnsupportedEncodingException;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.management.InvalidAttributeValueException;

import StealthNet.Security.Encryption;
import StealthNet.Security.HashedMessageAuthenticationCode;
import StealthNet.Security.MessageAuthenticationCode;
import StealthNet.Security.NonceGenerator;

/* StealthNet.DecryptedPacket Class Definition *******************************/

/**
 * A class to store the decrypted data passed between StealthNet clients. A 
 * StealthNet "packet" consists of three parts:
 *     - command
 *     - data
 *     - nonce
 *  
 * A message nonce is generated by a pseudo-random random generator. The message 
 * nonce is used to prevent replay attacks, because once the packet is read at 
 * the receiving end of the communications, the nonce is "consumed" and cannot 
 * be used again for future communications. The Packet class WILL allow packets 
 * to be created without a nonce (if a null NonceGenerator instance is passed to
 * the function). A higher layer should check whether or not this should be 
 * allowed.
 * 
 * @author Matt Barrie
 * @author Stephen Gould
 * @author Ryan Junee
 * @author Joshua Spence
 */
public class DecryptedPacket {
	/** Commands. */
    public static final byte CMD_NULL = 0x00;				/** used for acknowledgement */
    public static final byte CMD_LOGIN = 0x01;
    public static final byte CMD_LOGOUT = 0x02;
    public static final byte CMD_MSG = 0x03;
    public static final byte CMD_CHAT = 0x04;
    public static final byte CMD_FTP = 0x05;
    public static final byte CMD_LIST = 0x06;
    public static final byte CMD_CREATESECRET = 0x07;
    public static final byte CMD_SECRETLIST = 0x08;
    public static final byte CMD_GETSECRET = 0x09;
    
    /** 
     * Security-specific commands - these should never be returned to a client 
     * or server, but rather should always be handled within the Comms class. 
     */
    public static final byte CMD_AUTHENTICATIONKEY = 0x0A;	/** common key for Diffie-Hellman key exchange */
    public static final byte CMD_INTEGRITYKEY = 0x0B;		/** key for MAC generator */
    public static final byte CMD_NONCESEED = 0x0C;			/** seed for nonce generator */
    public static final byte CMD_PUBLICKEY = 0x0D;			/** asymmetric public key */
    
    /** Packet contents. */
    byte command;							/** The command being sent in the packet. */      
    final byte[] data;						/** The data being sent in the packet. */
    final byte[] nonce;						/** The pseudo-random nonce for this packet. */
    final MessageAuthenticationCode mac;	/** The MAC used to provide a message digest. */

    /** Null constructor with no digest and no nonce. */
    public DecryptedPacket() {
        this.command = DecryptedPacket.CMD_NULL;
        this.data = new byte[0];
        
        /** No nonce is available. */
        this.nonce = new byte[0];
        
        /** No MAC is available. */
        this.mac = null;
    }

    /** 
     * Constructor with no digest. Explicitly copies the data array contents.
     *
     * @param cmd The command to be sent in the packet.
     * @param d The data to be sent in the packet.
     */
    public DecryptedPacket(byte cmd, byte[] d) {
        this.command = cmd;
        
        if (d == null)
        	this.data = new byte[0];
        else {
        	this.data = new byte[d.length];
        	System.arraycopy(d, 0, this.data, 0, d.length);
        }
        
        /** No nonce is available. */
        this.nonce = new byte[0];
        
        /** No MAC is available. */
        this.mac = null;
    }
    
    /** 
     * Constructor with digest and nonce. Explicitly copies the data array 
     * contents.
     *
     * @param cmd The command to be sent in the packet.
     * @param dLen The length of the data array.
     * @param d The data to be sent in the packet.
     * @param mac The MessageAuthenticationCode instance to provide a MAC 
     * digest.
     * @param nonceGenerator The NonceGenerator instance to provide a nonce.
     */
    public DecryptedPacket(byte cmd, byte[] d, int dLen, MessageAuthenticationCode mac, NonceGenerator nonceGenerator) {
        this.command = cmd;
        
        /** Copy the data. */
        if (d == null)
        	this.data = new byte[0];
        else {
        	this.data = new byte[dLen];
        	System.arraycopy(d, 0, this.data, 0, dLen);
        }
        
        /** Create the nonce (if possible). */
        if (nonceGenerator != null)
        	this.nonce = nonceGenerator.getNext();
        else
        	this.nonce = new byte[0];
        
        this.mac = mac;
    }

    /** 
     * Constructor. This function must "undo" the effects of the toString() 
     * function, because this function converts the received data into a packet
     * at the receiving end of communications.
     * 
     * @param str A string consisting of the packet contents.
     */
    public DecryptedPacket(String str) {  
    	/** 
    	 * Add padding if necessary, to make the packet length an integer number
    	 * of bytes (each represented by 2 hexadecimal characters).
    	 */
    	if (str.length() % 2 == 1)
            str = "0" + str;
    	
        if (str.length() == 0) {
        	/** NULL packet. */
            this.command = DecryptedPacket.CMD_NULL;
            this.data = new byte[0];
            this.nonce = null;
            this.mac = null;
        } else {
        	/** Current index of the string. */
        	int current = 0;
        	
        	/** Command (1 byte). */
            this.command = (byte) (16 * Utility.singleHexToInt(str.charAt(current++)) + Utility.singleHexToInt(str.charAt(current++)));
            
            /** Data length (4 bytes). */
            int dataLen = Utility.hexToInt(str.substring(current, current + 8));
        	current += 8;
            
            /** Data (dataLen bytes). */
            this.data = new byte[dataLen];
            for (int i = 0; i < data.length; i++)
            	this.data[i] = (byte) (16 * Utility.singleHexToInt(str.charAt(current++)) + Utility.singleHexToInt(str.charAt(current++)));
            
            /** Nonce length (4 bytes). */
            int nonceLen = Utility.hexToInt(str.substring(current, current + 8));
        	current += 8;
            
            /** Nonce (nonceLen bytes). */
            this.nonce = new byte[nonceLen];
            for (int i = 0; i < nonce.length; i++)
            	this.nonce[i] = (byte) (16 * Utility.singleHexToInt(str.charAt(current++)) + Utility.singleHexToInt(str.charAt(current++)));
    		
    		/** No MAC is available. */
    		this.mac = null;
        }
    }

    /** 
     * Converts the packet to a string. This function must undo the effects of 
     * the StealthNet.DecryptedPacket(String) constructor, because this function
     * is used to convert a packet to a string for transmission at the sending 
     * end of communications.
     * 
     * @return A string representing the contents of the packet.
     */
    public String toString() {
    	String str = "";
        int lowHalfByte, highHalfByte;

        /** Command (1 byte).  */
        highHalfByte = (command >= 0) ? command : (256 + command);
        lowHalfByte = highHalfByte & 0xF;
        highHalfByte /= 16;
        str += Utility.HEXTABLE[highHalfByte];
        str += Utility.HEXTABLE[lowHalfByte];
        
        /** Data length (4 bytes). */
        str += Utility.intToHex(data.length);
        
        /** Data (data.length/2 bytes). */
        for (int i = 0; i < data.length; i++) {
        	highHalfByte = (data[i] >= 0) ? data[i] : 256 + data[i];
        	lowHalfByte = highHalfByte & 0xF;
            highHalfByte /= 16;
            str += Utility.HEXTABLE[highHalfByte];
            str += Utility.HEXTABLE[lowHalfByte];
        }
        
        /** Nonce length (4 bytes). */
        str += Utility.intToHex(nonce.length);
        
        /** Nonce (nonce.length/2 bytes). */
        for (int i = 0; i < nonce.length; i++) {
        	highHalfByte = (nonce[i] >= 0) ? nonce[i] : 256 + nonce[i];
        	lowHalfByte = highHalfByte & 0xF;
            highHalfByte /= 16;
            str += Utility.HEXTABLE[highHalfByte];
            str += Utility.HEXTABLE[lowHalfByte];
        }
        
        /** Done. */
        return str;
    }
    
    /**
     * Get the name of a command from its byte value. For debug purposes only.
     * 
     * @param command The byte value of the command to query the name of.
     * @return A String containing the name of the command.
     */
    public static String getCommandName(byte command) {
    	switch (command) {
    		case CMD_NULL:
				return "CMD_NULL";
    		case CMD_LOGIN:
    			return "CMD_LOGIN";
    		case CMD_LOGOUT:
    			return "CMD_LOGOUT";
    		case CMD_MSG:
				return "CMD_MSG";
    		case CMD_CHAT:
    			return "CMD_CHAT";
    		case CMD_FTP:
    			return "CMD_FTP";
    		case CMD_LIST:
    			return "CMD_LIST";
    		case CMD_CREATESECRET:
    			return "CMD_CREATESECRET";
    		case CMD_SECRETLIST:
				return "CMD_SECRETLIST";
    		case CMD_GETSECRET:
    			return "CMD_GETSECRET";
    		case CMD_AUTHENTICATIONKEY:
				return "CMD_AUTHENTICATIONKEY";
    		case CMD_INTEGRITYKEY:
				return "CMD_INTEGRITYKEY";
    		case CMD_NONCESEED:
    			return "CMD_NONCESEED";
    		case CMD_PUBLICKEY:
    			return "CMD_PUBLICKEY";
			default:
				return "UNKNOWN";
    	}
    }
    
    /**
     * Get a string representation of the packet. For debug purposes only. 
     * 
     * @return A comma-separated string containing the the value of each of the
     * packet's fields. For purely cosmetic purposes, newline characters will be
     * replaced by semicolons.
     */
    public String getDecodedString() {
    	String str = "";
    	
    	/** Packet name. */
    	str += getCommandName(command);
    	str += ", ";
    	
    	/** Packet data. */
    	if (data.length > 0)
    		str += (new String(data)).replaceAll("\n", ";");
    	else
    		str += "null";
    	str += ", ";
    	
    	/** Packet nonce. */
    	if (nonce != null && nonce.length > 0)
    		str += Utility.getHexValue(nonce);
    	else
    		str += "null";
    	
    	return str;
    }
    
    /**
     * Encrypt this packet.
     * 
     * @param e The encryption instance to encrypt the packet. If null, then it
     * will be assumed that the packet is not encrypted.
     * @return The encrypted packet.
     * 
     * @throws BadPaddingException 
     * @throws IllegalBlockSizeException 
     * @throws UnsupportedEncodingException 
     * @throws IllegalArgumentException 
     * @throws InvalidAttributeValueException 
     */
    public EncryptedPacket encrypt(Encryption e) throws UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, InvalidAttributeValueException, IllegalArgumentException {
    	if (e != null) {
	    	final byte[] encryptedData = e.encrypt(this.toString()).getBytes();
	    	return new EncryptedPacket(encryptedData, encryptedData.length, HashedMessageAuthenticationCode.DIGEST_BYTES, this.mac);
    	} else {
    		return new EncryptedPacket(this.toString().getBytes(), this.toString().getBytes().length, HashedMessageAuthenticationCode.DIGEST_BYTES, this.mac);
    	}
    }
}

/******************************************************************************
 * END OF FILE:     DecryptedPacket.java
 *****************************************************************************/