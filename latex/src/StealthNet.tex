\documentclass[a4paper,11pt]{article}

\usepackage{StealthNet}

% Graphics directory
\ifpdf
    % pdflatex requires bitmap images.
    \graphicspath{{./img/png/}}
\else
    % latex requires vector images.
    \graphicspath{{./img/eps/}}
\fi

% Title page details
\title{StealthNet Security Implementation}
\author{Joshua Spence \and Ahmad Al Mutawa}
\date{April 2012}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle

% INTRODUCTION
\section{Introduction}
This document outlines the modifications that were made to the \packageName{} in
order to secure the communications provided by the application. The provided
source code for the \packageName{} package is vulnerable to a wide range of 
\singleQuote{attacks}, including but not limited to the following.

\begin{description}

\item[Eavesdropping] The communications implemented in \packageName{} transmit
messages in cleartext over sockets. This allows an attacker who has gained 
access to data paths in the network to eavesdrop on \packageName{} 
communications.

\item[Data Modification] As a follow-on from \attackName{eavesdropping}, an 
attacker would additionally be able to alter the transmitted data. An attacker
can modify the data in the packet without the knowledge of the sender or 
receiver.

\item[Denial-of-Service] A \attackName{denial-of-service} attack prevents normal
of the \serviceName{} service. An attacker could overwhelm the \serviceName{} 
server such that it is unable to process legitimate connections from legitimate 
users. Alternatively, an attacker could simply block network traffic completely,
resulting in a complete lack of communication between \serviceName{} peers.

\item[Man-in-the-Middle] A \attackName{man-in-the-middle} attack occurs when 
someone between two \serviceName{} peers is actively monitoring, capturing, and 
controlling your communication transparently. An attacker makes independent 
connections with the victims and relays messages between them, making them 
believe that they are talking directly to each other over a private connection.

\end{description}

% AUTHENTICATION
\section{Authentication}

\subsection{Introduction}

\subsection{Details}
The \algorithm{Diffie-Hellman key exchange} method allows two parties that have 
no prior knowledge of each other to jointly establish a shared secret key over 
an insecure communications channel. \algorithm{Diffie-Hellman key exchange} 
involves combining one party's private key with the other party's public key in 
order to generate a number. The other party does the same with its own private 
key and the original party's public key. Through the magic of 
\algorithm{Diffie-Hellman}, both parties are able to generate the same shared 
secret key.

The protocol depends on the discrete logarithm problem for its security. It 
assumes that it is computationally infeasible to calculate the shared secret key
$k = generator^{ab} \bmod prime$ given the two public values 
$generator^{a} \bmod prime$ and $generator^{b} \bmod prime$ when the prime is 
sufficiently large. Maurer has shown that breaking the 
\algorithm{Diffie-Hellman protocol} is equivalent to computing discrete 
logarithms under certain assumptions.

\subsection{Implementation}
Authentication is implemented in \packageName{} with the 
\verb+KeyExchange+ interface. In particular, the \verb+DiffieHellmanKeyExchange+
class implements the \verb+KeyExchange+ interface.

The \verb+KeyExchange+ interface provides a method for getting the public key
value, as well as a method to generate the shared secret. The actual 
\algorithm{Diffie-Hellman} algorithm is implemented in the 
\verb+DiffieHellmanKeyExchange+ class, which either generates or is passed a 
large prime number and a generator in order to initialise the 
\algorithm{Diffie-Hellman} public-private key pair. In our implementation of 
\algorithm{Diffie-Hellman key exchange}, 1024 bit keys are used.

\algorithm{Diffie-Hellman key exchange} is initialised in the 
\verb+initiateSession()+ function, after a communications socket has been 
established. The initiator of the connection (usually the client), calls the
\verb+initKeyExchange()+ function, which generates their 
\algorithm{Diffie-Hellman} key pairs and transmits their own public key value to
the peer in a \verb+CMD_AUTHENTICATIONKEY+ packet. Once the public key has been 
transmitted, the \serviceName{} peer calls the \verb+waitForKeyExchange()+ 
function, rejecting all incoming packets until the peer receives the other
party's public key value. On the accepting end of the communications, the peer
does not initiate key exchange but rather calls \verb+waitForKeyExchange()+ 
after establishing the communications socket.

When the \verb+waitForKeyExchange()+ function returns, the StealthNet 
communications class will have had its \verb+authenitcationProvider+ and 
\verb+authenticationKey+ variables set.

\algorithm{Diffie-Hellman key exchange} is implemented as a feature of the
\serviceName{} \verb+Comms+ class, which means that every connection to and from
a host will use a different public-private key pair.
 
% ENCRYPTION
\section{Encryption}

\subsection{Introduction}

\subsection{Details}

\subsection{Implementation}

% INTEGRITY
\section{Integrity}

\subsection{Introduction}

\subsection{Details}

\subsection{Implementation}

% REPLAY PREVENTION
\section{Replay prevention}

\subsection{Introduction}
Replay prevention is the process by which an attacker stores some transmitted 
data and chooses to ``replay'' (that is, retransmit) that data at a later time 
in an unaltered form. Since the message has not been modified in any way, the 
server would otherwise be unaware that this message is being replayed. The MAC
digest of the message would remain intact and the message itself would remain
encrypted. And so the party receiving the replayed message may be convinced that
this is a legitimate request from another party, when in fact it is not.

In order to prevent this kind of attack, we need to implement a means of 
``replay prevention''. The implementation of replay prevention in \packageName{}
is detailed in this section.

\subsection{Details}
In order to implement ``replay prevention'' in \packageName{}, we decided to 
append each packet with a `token' before it was being transmitted. Each token 
should be unique and follow some predictable sequence. In this way, both parties
are able to predict and verify valid token numbers. Once the receiving party 
receives a packet, it marks the token number of that packet as having been 
received. Thus, if an attacker tries to replay this same message at a later 
time, the receiving party is able to detect the replay attack (by way of
checking the token number) and discard the packet.

We decided to use a pseudo-random number generator (PRNG) to generate packet 
tokens. So that the tokens would follow a predictable sequence, a seeded PRNG
was used and the seed was shared between both parties. Each party has a PRNG for
transmitting packets (which would correspond with the other parties receiving 
PRNG) and for receiving packets (which would correspond with the other parties 
transmitting PRNG). Both parties maintain a set of received tokens, and this 
set is consulted every time a packet is received, in order to determine its
validity.

\subsection{Implementation}
Packet tokens are provided by the \verb+TokenGenerator+ interface, which 
provides the \verb+isAllowed()+ function to verify whether a packet with a given
token should be accepted or discard; as well as a \verb+getNext()+ function for
generating the tokens. A PRNG token generator is implemented in the 
\verb+PRNGTokenGenerator+ class. This class uses a seeded number generator for
token generation.

% IMPLEMENTATION
\section{Implementation}
The implementation of the various security measures implemented in 
\packageName{} are detailed in the previous sections. In order to share
cryptographic keys between parties, modifications were made to the 
\packageName{} \verb+Packet+ class to accomodate three additional command types:
\begin{itemize}
\item \verb+CMD_AUTHENTICATIONKEY+: For exchanging Diffie-Hellman keys
between the parties.
\item \verb+CMD_INTEGRITYKEY+: For exchanging ``Hmac-MD5'' keys used 
for Hashed Message Authentication Code (HMAC) generation and verification.
\item \verb+CMD_TOKENSEED+: A seed for a \verb+PRNGTokenGenerator+, 
which is used to generate and test token numbers that are appended to a packet
in order to prevent replay prevention.
\end{itemize}

These additional packet commands should not appear during normal execution of 
\serviceName{}, but rather should only exist during execution of the
\verb+initiateSession()+ and \verb+acceptSession()+ functions.

In order to share additional data between communicating parties, the 
\serviceName{} \verb+Packet+ class was exended such that it is composed of the
following fields:
\begin{itemize}
\item \verb+command+: The command type being transmitted in the 
packet.
\item \verb+data+: The command data being transmitted in the packet.
\item \verb+token+: The unique token, generated by a pseudo-random
number generator in order to allow a given message to be received only once on 
the receiving end of the communications.
\item \verb+digest+: The MAC digest of the packet contents, used to 
verify packet integrity.
\end{itemize}

% VULNERABILITIES
\section{Vulnerabilities}
Whilst various security protocols have been implemented in \serviceName{} in 
order to provide authentication, confidentialty, integrity and replay 
prevention; the communications application is is still by no means completely
secure. Of particular mention, the application is still vulnerable to a 
\algorithm{Man-in-the-Middle attack}.

% CHOSEN PLAINTEXT ATTACK

% CONCLUSION
\section{Conclusion}

\end{document}
